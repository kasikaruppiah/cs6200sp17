<b>BM25</b><br><br>Query - <b>What is the type of a module?	(I don't want the entire literature on
Abstract Data Types here, but I'm not sure how to phrase this to avoid it.
I'm interested in questions about how one can check that a module "matches"
contexts in which it is used.)</b><br><br><u><b>CACM-3105.html</b></u><br>
 <b>The</b> approach <b>can</b> be <b>used</b> <b>to</b> extend any strongly-typed 
language, <b>but</b> <b>is</b> particularly suitable for extending
languages <b>that</b> support <b>the</b> notion <b>of</b> <b>abstract</b> <b>data</b> 
<b>types</b><br><br><u><b>CACM-3031.html</b></u><br>  First, <b>it</b> <b>is</b> shown <b>how</b>
<b>the</b> use <b>of</b> algebraic axiomatizations <b>can</b> simplify 
<b>the</b> process <b>of</b> proving <b>the</b> correctness <b>of</b> an implementation
<b>of</b> an <b>abstract</b> <b>data</b> <b>type</b><br><br><u><b>CACM-2470.html</b></u><br>  <b>It</b> <b>is</b> shown
<b>how</b> <b>the</b> system <b>can</b> be <b>used</b> <b>to</b> build composite 
<b>data</b> <b>types</b> out <b>of</b> simper ones with <b>the</b> operations <b>of</b> rowing,
structuring, and uniting<br><br><u><b>CACM-2939.html</b></u><br>  By 
means <b>of</b> programming examples, <b>the</b> utility <b>of</b> <b>the</b> three
kinds <b>of</b> abstractions <b>in</b> program construction 
<b>is</b> illustrated, and <b>it</b> <b>is</b> shown <b>how</b> CLU programs may
be written <b>to</b> use and implement abstractions<br><br><u><b>CACM-2867.html</b></u><br> <b>It</b> <b>is</b> shown <b>that</b> <b>the</b> concepts <b>of</b> <b>module</b> and
level do <b>not</b> coincide <b>in</b> <b>a</b> hierarchy <b>of</b> functions<br><br><u><b>CACM-1359.html</b></u><br>  Each <b>data</b> string with 
<b>the</b> structured <b>data</b> environment (<b>data</b> bank) <b>is</b> explicitly
or implicitly related <b>to</b> <b>a</b> format declaration
residing <b>in</b> <b>a</b> format library<br><br><u><b>CACM-2582.html</b></u><br> 
 <b>It</b> <b>is</b> based <b>on</b> <b>the</b> concept <b>of</b> critical working set, <b>a</b>
working set <b>which</b> does <b>not</b> contain <b>the</b> next memory 
reference<br><br><u><b>CACM-0497.html</b></u><br>  <b>The</b> problem
comprises <b>the</b> determination, given N, <b>of</b> <b>the</b> 
N points <b>of</b> subdivision <b>of</b> <b>a</b> given interval (<b>a</b>,B) and
<b>the</b> corresponding line segments, <b>that</b> give <b>the</b> 
best least squares fit <b>to</b> <b>a</b> function g(x) <b>in</b> <b>the</b> interval<br><br><u><b>CACM-2247.html</b></u><br>



<b>On</b> <b>the</b> Criteria <b>To</b> Be <b>Used</b> <b>in</b> Decomposing Systems into Modules

<b>This</b> paper discusses modularization as <b>a</b> mechanism
for improving <b>the</b> flexibility ad comprehensibility 
<b>of</b> <b>a</b> system while allowing <b>the</b> shortening <b>of</b> its development
time<br><br><u><b>CACM-1847.html</b></u><br>  <b>In</b> terms <b>of</b> 
storage our algorithm <b>is</b> similar <b>to</b> <b>that</b> <b>of</b> Gotlieb and
Corneil and superior <b>to</b> <b>that</b> <b>of</b> Welch; <b>in</b> terms 
<b>of</b> speed <b>it</b> <b>is</b> similar <b>to</b> <b>that</b> <b>of</b> Welch and superior
<b>to</b> <b>that</b> <b>of</b> Gotlieb and Corneil<br><br>