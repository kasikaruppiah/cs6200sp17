<b>BM25</b><br><br>Query - <b>I am interested in distributed algorithms - concurrent programs in
which processes communicate and synchronize by using message passing.
Areas of particular interest include fault-tolerance and techniques
for understanding the correctness of these algorithms.</b><br><br><u><b>CACM-3043.html</b></u><br>  <b>These</b> 
<b>processes</b> <b>communicate</b> <b>and</b> <b>synchronize</b> <b>by</b> means <b>of</b> procedure
calls <b>and</b> guarded regions<br><br><u><b>CACM-3128.html</b></u><br>



Synchronization with Eventcounts <b>and</b> Sequencers

Synchronization <b>of</b> <b>concurrent</b> <b>processes</b> requires controlling <b>the</b> relative 
ordering <b>of</b> events <b>in</b> <b>the</b> <b>processes</b><br><br><u><b>CACM-2342.html</b></u><br>  Solutions have been given
<b>for</b> <b>the</b> mutual exclusion problem <b>and</b> associated 
subproblems, <b>in</b> <b>the</b> form <b>of</b> parallel <b>programs</b>, <b>and</b> informal
proofs <b>of</b> <b>correctness</b> have been given <b>for</b> 
<b>these</b> solutions<br><br><u><b>CACM-3141.html</b></u><br>



An Improved Algorithm <b>for</b> Decentralized Extrema-Finding
<b>in</b> Circular Configurations <b>of</b> <b>Processes</b>

This note presents an improvement to LeLann's
algorithm <b>for</b> finding <b>the</b> largest (or smallest) <b>of</b> a set <b>of</b> uniquely
numbered <b>processes</b> arranged <b>in</b> a circle, <b>in</b> <b>which</b> no central
controller exists <b>and</b> <b>the</b> number <b>of</b> <b>processes</b> is not known a priori<br><br><u><b>CACM-2376.html</b></u><br>
 This is demonstrated <b>for</b> a system consisting <b>of</b> 
many sending <b>processes</b> <b>which</b> deposit messages <b>in</b> a buffer
<b>and</b> many receiving <b>processes</b> <b>which</b> remove messages 
from that buffer<br><br><u><b>CACM-1854.html</b></u><br>



On Multiprogramming, Machine Coding, <b>and</b> Computer Organization

<b>The</b> author feels that <b>the</b> interrupt feature
<b>which</b> is available <b>in</b> most modern computers is 
a potent source <b>of</b> programming pitfalls <b>and</b> errors, <b>and</b>
that it therefore may heavily contribute to <b>the</b> 
unreliability <b>of</b> <b>programs</b> making use <b>of</b> it<br><br><u><b>CACM-2912.html</b></u><br>  <b>These</b> <b>include</b> a solution 
to <b>the</b> general problem <b>in</b> <b>which</b> a read is repeated if
it might have obtained an incorrect result, <b>and</b> 
two <b>techniques</b> <b>for</b> transmitting messages between <b>processes</b><br><br><u><b>CACM-2949.html</b></u><br>



A <b>Correctness</b> Proof <b>of</b> a Topology Information
Main tenance Protocol <b>for</b> a <b>Distributed</b> Computer 
Network

<b>In</b> order <b>for</b> <b>the</b> nodes <b>of</b> a <b>distributed</b> computer
network to <b>communicate</b>, each node must have 
information about <b>the</b> network's topology<br><br><u><b>CACM-2865.html</b></u><br>  <b>Techniques</b> <b>for</b> verifying 
<b>these</b> properties are presented <b>and</b> illustrated <b>by</b>
application to <b>the</b> dining philosophers problem<br><br><u><b>CACM-3148.html</b></u><br>



High Level Programming <b>for</b> <b>Distributed</b> Computing

Programming <b>for</b> <b>distributed</b> <b>and</b> other loosely coupled systems
is a problem <b>of</b> growing <b>interest</b><br><br>