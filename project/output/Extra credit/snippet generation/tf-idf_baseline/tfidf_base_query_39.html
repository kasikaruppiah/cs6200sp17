<b>tf-idf</b><br><br>Query - <b>What does type compatibility mean in languages that allow programmer
defined types?  (You might want to restrict this to "extensible" languages
that allow definition of abstract data types or programmer-supplied
definitions of operators like *, +.)</b><br><br><u><b>CACM-2651.html</b></u><br>  The resulting
treatment <b>of</b> <b>data</b> <b>types</b> includes provision for 
<b>programmer</b>-<b>defined</b> <b>data</b> <b>types</b> <b>data</b> <b>types</b> and generic
routines, <b>programmer</b> control over <b>type</b> conversion, 
and very flexible <b>data</b> <b>type</b> behavior, <b>in</b> a context <b>that</b>
allows efficient compiled code and compact <b>data</b> 
representation<br><br><u><b>CACM-2958.html</b></u><br>



<b>Abstract</b> <b>Data</b> <b>Types</b> and the Development <b>of</b> <b>Data</b> Structures

<b>Abstract</b> <b>data</b> <b>types</b> can play a significant role
<b>in</b> the development <b>of</b> software <b>that</b> is reliable, 
efficient, and flexible<br><br><u><b>CACM-3105.html</b></u><br>
 The approach can be used <b>to</b> extend any strongly-typed 
language, but is particularly suitable for extending
<b>languages</b> <b>that</b> support the notion <b>of</b> <b>abstract</b> <b>data</b> 
<b>types</b><br><br><u><b>CACM-2406.html</b></u><br>  <b>This</b> paper reviews past work <b>in</b> the <b>data</b>
<b>definition</b> language for describing both logical 
and physical aspects <b>of</b> <b>data</b><br><br><u><b>CACM-3103.html</b></u><br>  <b>In</b> <b>this</b> paper 
a system for automatically choosing efficient implementations
for <b>abstract</b> <b>types</b> from a library <b>of</b> implementations 
is discussed<br><br><u><b>CACM-2603.html</b></u><br>  <b>In</b> <b>this</b> paper <b>this</b> 
result is extended, showing <b>that</b>, <b>in</b> fact, the first class
is equivalent <b>to</b> the class <b>of</b> deterministic 
context free <b>languages</b><br><br><u><b>CACM-1861.html</b></u><br>  Users <b>of</b> the 
language can define new <b>operators</b> and/<b>or</b> <b>data</b> <b>types</b>
into the MAD language, so <b>that</b> their use appears 
as if they were predefined<br><br><u><b>CACM-2940.html</b></u><br>  <b>In</b> <b>this</b> paper the abstraction techniques
are extended from simple <b>data</b> representation 
and function <b>definition</b> <b>to</b> the iteration statement, the
most important poin t <b>of</b> interaction between <b>data</b> 
and the control structure <b>of</b> the language itself<br><br><u><b>CACM-2956.html</b></u><br>  Among
these are the need for a notation for iterating 
over the elements <b>of</b> any finite set (instead <b>of</b> the
more narrow for i:= 1 <b>to</b> n notation), the use <b>of</b> 
the domain <b>of</b> an array as a <b>data</b> <b>type</b>, the need for
a simple notation for allowing <b>types</b> <b>of</b> parameters 
<b>to</b> be themselves parameters (but <b>in</b> a restrictive fashion),
and resulting problems with conversion <b>of</b> 
values from one <b>type</b> <b>to</b> another<br><br><u><b>CACM-2316.html</b></u><br>



Programming <b>Languages</b>: History and Future

<b>This</b> paper discusses both the history and future
<b>of</b> programming <b>languages</b> (= higher level <b>languages</b>)<br><br>